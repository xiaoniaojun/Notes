# 第一章 走入并行世界

### 1.1 何去何从的并行计算

本章主要讨论**并行**是如何出现的。

#### 1.1.1 忘掉那该死的并行

Linus Torvalds 喷了并行计算。他说并行计算只在**图像处理**和**服务端程序**上有用。

虽然并行程序难以设计，但并行更符合客观世界。

#### 1.1.2 可怕的现实：摩尔定律的失效

**摩尔定律**失效：每过18个月到24个月，芯片的性能将提高一倍。但是现在5GHz似乎是一个瓶颈了。

#### 1.1.3 柳暗花明：不断前进

虽然主频提升遇到瓶颈，但是多核CPU却开始起步。

#### 1.1.4 光明或是黑暗

摩尔定律被硬件设计师推锅给软件设计师来维持。并行时代的到来，也意味着程序员的“黑暗”时代来临。

### 1.2 你必须知道的几个概念

介绍了并行中的几个概念，并对他们进行区分。

#### 1.2.1 同步(Synchronous)和异步(Asynchronous)

#### 1.2.2 并发(Concurrency)与并行(Parallelism)

它们都可以表示*多个任务一起执行*，但侧重点有所不同。

**并发**：偏重于多个任务交替执行。
**并行**：真正意义上的“同时执行”。

#### 1.2.3 临界区

表示一种公共资源或公共数据，可以被多个线程共享，但每次只能有一个线程去使用它。如果此时有其他线程也想使用，就必须等待。

#### 1.2.4 阻塞(Blocking)和非阻塞(Non-Blocking)

**阻塞**：一个线程占用了临界区资源，其他想要使用这个资源的线程就必须等待。等待会导致线程被挂起，这种情况就是**阻塞**。
**非阻塞**:强调所有线程都不断执行，没有阻塞。

#### 1.2.5 死锁(Blocking)、饥饿(Starvation)和活锁(Livelock)

**死锁**:彼此之间占用了彼此需要的资源，又迟迟不肯释放自己所占用的资源，导致这个互相等待状态永远维持下去。
**饥饿**:某个或多个线程由于种种原因，一直无法获得所需要的资源，导致一直无法执行。
**活锁**:多个线程主动将资源让给其他线程，导致资源不断在多个线程中跳动，从而多方都无法拿到资源而正常执行。

### 1.3 并发级别

可以理解为并发策略。
分为阻塞、无饥饿、无障碍、无锁、无等待几种。

#### 1.3.1 阻塞(Blocking)

使用**syhchronized**或者**重入锁**会得到阻塞的线程。

#### 1.3.2 无饥饿(Starvation-Free)

**非公平的锁**会允许高优先级的线程插队，可能引发**饥饿**。如果采用**公平锁**，则就不会引起饥饿，但也**优先级**也就失效了。

#### 1.3.3 无障碍(Obstruction-Free)

无障碍：一种非阻塞调度。简单说来就是允许任何线程进入临界区而不挂起，但是如果对共享数据的修改可能引起冲突，就会回滚这个操作。

一种实现是定义一个“一致性标记”来实现。在操作之前先读取并保存这个标记，如果操作完成后再次读取，标记没有被改变，说明操作有效；否则回滚重新操作。

#### 1.3.4 无锁(Lock-Free)

**无障碍**的加强，在**无障碍**的基础上，保证必然有一个线程能够在有限的步骤中完成操作离开临界区。

*可能会引发**饥饿***。

#### 1.3.5 无等待(Wait-Free)

在**无锁**的基础上要求所有线程都必须在有限的步骤能完成操作，*这样就不会引起**饥饿***。

可以细分为**有界无等待**和**线程数无关的无等待**几种。

**写时拷贝RCU**(Read-Copy-Update)是一种典型的无等待结构。

### 1.4 有关并行的两个重要定律

Amdahl定律和Gustafson定律。它们说的是：可并行代码越多，CPU核心数越多，执行速度就越快。

### 1.5 JMM

### 1.5.1 原子性(Atomicity)

原子性是指一个操作是不可中断的。

### 1.5.2 可见性(Visibility)

指当一个线程修改了某个共享变量的值，其他线程能否立即知道这个修改。

### 1.5.3 有序性(Ordering)

由于重排序的存在，并行指令的执行顺序不一定会按照我们的直觉执行。

### 1.5.4 Happens-Before规则

规定了哪些情况下不能重排序，它是JMM顺序一致性基本保障的规则。